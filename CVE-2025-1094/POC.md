# CVE-2025-1094: SQL Injection in PostgreSQL - Analysis & Emulation

## Overview

This repository contains a comprehensive analysis and proof-of-concept emulation of **CVE-2025-1094**, a critical SQL injection vulnerability in PostgreSQL. The vulnerability was analyzed on March 14, 2025, and demonstrates how encoding mismatches can lead to unauthorized file access and potential remote code execution.

---

## Vulnerability Details

### CVE Information

- **CVE ID**: CVE-2025-1094
- **Type**: SQL Injection (CWE-149: Improper Neutralization of Quoting Syntax)
- **Severity**: Critical
- **CVSS 3.1 Base Score**: 8.1
- **Affected Versions**: PostgreSQL < 17.3, 16.7, 15.11, 14.16, 13.19

### Impact

- Access to sensitive data
- Remote code execution (RCE)
- Real-world exploitation documented in:
  - BeyondTrust incident (17 enterprise customers affected)
  - U.S. Treasury Department breach

### Root Cause

The vulnerability stems from improper handling in PostgreSQL's libpq functions:

- `PQescapeLiteral()`
- `PQescapeIdentifier()`
- `PQescapeString()`
- `PQescapeStringConn()`

These functions fail to neutralize quoting syntax when results are used to construct input for the `psql` command-line tool. The vulnerability is exacerbated when:

- `client_encoding` is set to **BIG5**
- `server_encoding` is set to **EUC_TW**

This encoding mismatch allows attackers to bypass query sanitization mechanisms.

---

## Attack Vector

The exploit uses the following methodology:

1. Inject a PostgreSQL DO block via a vulnerable endpoint
2. Create a large object to store sensitive data
3. Read `/etc/passwd` using `pg_read_file()`
4. Write the file contents to the large object using `lo_put()`
5. Export the large object to the filesystem using `lo_export()`

---

## Project Structure

```
.
├── app.py                      # Flask application with vulnerable endpoint
├── exploit.py                  # Python exploit script
├── init.sql                    # Database initialization script
├── Dockerfile                  # Flask app container configuration
├── Dockerfile.db               # PostgreSQL container configuration
├── docker-compose.yml          # Service orchestration
└── README.md                   # This file
```

---

## File Contributions

| File | Purpose | Contribution to PoC | Necessity |
|------|---------|---------------------|-----------|
| `exploit.py` | Sends POST request with DO block to create and export large object, reading `/etc/passwd` | Triggers SQL injection, exploits encoding mismatch to execute arbitrary SQL commands | Enables exploit execution, critical for PoC impact |
| `app.py` | Flask application exposing `/vuln-endpoint` that executes raw SQL via psql | Provides vulnerable endpoint for exploit | Entry point for exploit, necessary for vulnerability demonstration |
| `init.sql` | Creates test table with `id VARCHAR(255)` for string inputs | Sets up schema for injection, ensures payload execution without type errors | Database setup for exploit, essential for SQL injection |
| `Dockerfile` | Builds Flask app container with necessary dependencies | Creates isolated app service for endpoint deployment | Deploys vulnerable app, critical for PoC reproducibility |
| `docker-compose.yml` | Defines and links db and app services with specific configurations | Orchestrates setup, ensures encoding mismatch and service dependencies | Links services, essential for environment setup and isolation |
| `Dockerfile.db` | Builds PostgreSQL container with EUC_TW encoding | Creates vulnerable database with required encoding | Sets up database with required encoding, critical for vulnerability trigger |

---

## Prerequisites

- Docker and Docker Compose installed
- Python 3.x with `requests` library
- Linux/macOS environment (for shell commands)
- Root/sudo access (for Docker operations)

---

## Setup & Execution

### Step 1: Build and Start Services

```bash
sudo docker compose up --build
```

**What it does**: Builds and starts Docker Compose services (db and app), creating containers with updated images and linking them in the `postgre_default` network. Ensures the vulnerable environment is configured with db using EUC_TW encoding and app exposing `/vuln-endpoint` on port 5000.

**Why it's needed**: Sets up the necessary environment for the exploit to function correctly.

---

### Step 2: Verify Connectivity

```bash
curl -X POST http://localhost:5000/vuln-endpoint -d "input=test"
```

**What it does**: Sends a POST request to the Flask app's endpoint with `input=test`, expecting "Executed" response.

**Why it's needed**: Confirms the endpoint is accessible and functional before proceeding with the exploit.

---

### Step 3: Execute the Exploit

```bash
python3 exploit.py
```

**What it does**: Runs the exploit script, sending a POST request with a DO block to create a large object, write `/etc/passwd` to it, and export to `/tmp/payload`. Prints execution status and triggers the SQL injection.

**Why it's needed**: Executes the core exploit, demonstrating how attackers can access sensitive data via encoding mismatch.

---

### Step 4: Verify Running Containers

```bash
sudo docker ps
```

**What it does**: Lists running containers, verifying `postgre-app-1` and `postgre-db-1` are active.

**Why it's needed**: Confirms all necessary services are running before validation steps.

---

### Step 5: Validate Exploit Success

```bash
sudo docker exec -it <container-id> bash -c "LC_ALL=C ls -l /tmp/payload && LC_ALL=C cat /tmp/payload"
```
<img width="1418" height="492" alt="image" src="https://github.com/user-attachments/assets/a5fcf88b-b2b8-4e8d-8790-1fb27d5ea3e4" />

Replace `<container-id>` with the PostgreSQL container ID from `docker ps`.

**What it does**: Executes a command in the database container, listing and displaying `/tmp/payload` with English output. Verifies the exploit retrieved `/etc/passwd`.

**Why it's needed**: Confirms the exploit successfully accessed sensitive data.

---

### Step 6: Verify Database Modifications

```bash
sudo docker exec -it <container-id> psql -U postgres -d postgres -c "SELECT * FROM test;"
```

**What it does**: Runs a SQL query in the database container, selecting all records from the test table. Verifies the INSERT from the exploit executed successfully.

**Why it's needed**: Provides additional verification that the DO block executed and modified the database.

---

### Step 7: Cleanup

```bash
sudo docker compose down
```

**What it does**: Stops and removes containers, networks, and volumes, cleaning up the environment.

**Why it's needed**: Frees resources and ensures no residual services affect future tests.

---

## Technical Details

### Encoding Mismatch Mechanism

The vulnerability exploits the difference between BIG5 (client) and EUC_TW (server) character encodings. Certain byte sequences that are valid in one encoding but interpreted differently in another can bypass escaping mechanisms designed for standard ASCII.

### Exploitation Flow

1. User sends crafted input through `/vuln-endpoint`
2. Flask app receives input and constructs SQL using libpq escaping functions
3. Due to encoding mismatch, escape characters are misinterpreted
4. PostgreSQL executes the injected DO block
5. Attacker gains file read/write access and data exfiltration capability

### Why Raw psql Execution is Vulnerable

The exploit's success depends on executing raw SQL via `subprocess.run(["psql", ...])`, bypassing safe query parameter handling. This pattern is discouraged in production environments.

---

## Mitigation Strategies

1. **Update PostgreSQL**: Upgrade to patched versions (17.3+, 16.7+, 15.11+, 14.16+, 13.19+)
2. **Use Prepared Statements**: Always use parameterized queries instead of string concatenation
3. **Encoding Consistency**: Ensure client and server encodings match and use standard encodings (UTF-8 preferred)
4. **Input Validation**: Implement strict validation and sanitization of user inputs
5. **Principle of Least Privilege**: Restrict database user permissions to only necessary operations
6. **Avoid Raw Command Execution**: Never execute raw SQL via shell commands; use ORM/driver-level query execution
7. **Monitor Encoding**: Verify encoding settings in production PostgreSQL configurations

---

## Important Notes

- This repository is for **educational and authorized testing purposes only**
- Do not use this exploit against systems you do not own or have explicit permission to test
- The vulnerability requires specific encoding configuration to exploit; standard PostgreSQL deployments may be less susceptible
- Always follow responsible disclosure practices when discovering vulnerabilities

---

## References

- CVE-2025-1094 Security Advisory
- PostgreSQL Security Documentation
- CWE-149: Improper Neutralization of Quoting Syntax
- BleepingComputer: BeyondTrust Incident Report
- The Register: U.S. Treasury Department Breach Analysis

